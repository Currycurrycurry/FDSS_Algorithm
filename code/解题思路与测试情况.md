# 解题思路与测试情况

17302010063 20212226543 黄佳妮 软件工程

## 第一题

本题完整的源代码见[第一题.py](./第一题.py)

### 解题思路

#### 核心算法：树的遍历

#### 核心数据结构：二叉树

乍一看这道题，「删除一条边使得剩下的两棵子树的节点和的乘积最大」似乎复杂，实则只需考虑两个操作：

假设节点总数为N:

- 遍历树，并且计算当前所遍历节点的子树的和，存在一个数组里。这一步因为要遍历所有节点，并且开辟一个额外的新数组存和，所以时间复杂度和空间复杂度都是O(N)。
- 因为所谓两棵子树的节点和的乘积，就是当前所遍历的子树的和 * （所有节点的和 - 当前所遍历的子树的和），只需要先计算所有节点的和，再依次和第一步中的数组中的和进行乘积的比较，这一步只需要O(n)的时间复杂度，最终就可获得这个最大的乘积。

综上，因为两步是先后进行的，所以时间复杂度和空间复杂度都是O(N)

### 测试用例

#### 功能测试

|   功能描述   | 输入                               | 输出 |
| :----------: | ---------------------------------- | ---- |
|  完全二叉树  | 1 2 3 4 5 6 7                      | 192  |
| 非完全二叉树 | 1 2 3 4 5 6                        | 110  |
|  完全二叉树  | 1 1 1 1 1 1 1                      | 12   |
| 非完全二叉树 | 1, null, 2, 3, 4, null, null, 5, 6 | 90   |

#### 边界值测试

| 边界描述               | 输入                                 | 输出 |
| ---------------------- | ------------------------------------ | ---- |
| 退化为链表的树(左节点) | 1 2 None 3 None 4 None 5 None 6 None | 110  |
| 退化为链表的树(右节点) | 1 None 2 None 3 None 4 None 5 None 6 | 110  |

#### 特殊输入测试

| 描述       | 输入 | 输出 |
| ---------- | ---- | ---- |
| 空树       | None | -inf |
| 只有根节点 | 0    | 0    |
| 无输入     | /    | -inf |



## 第二题

本题完整的源代码见[第二题.py](./第二题.py)

### 解题思路

#### 核心算法：邻接链表建图 + 拓扑排序 + 剪枝 + 判断回路 + 判断等式

#### 核心数据结构：图 / 数组

理想情况下，可以构成排行榜即存在对应元素的拓扑排序且拓扑排序的结果是一条单一确定的链表，而非理想情况下可以分成以下几种情况：

- 遍历过程中存在回路：信息包含冲突

- 遍历后与并查集等式集存在矛盾：信息包含冲突

- 遍历后存在两个节点关系无法判断（即图中不存在）：信息不完全

- 所给关系式个数<= N - 2: 信息不完全

  分别对图和遍历后的stack进行判断即可。

  时间与空间复杂度为O(N+M)。

### 测试用例

#### 功能测试

| 功能描述 | 输入            | 输出   |
| :------: | --------------- | ------ |
|  能确定  | 3 3 0>1 1<2 0>2 | 能确定 |

#### 边界值测试

| 边界描述     | 输入                | 输出         |
| ------------ | ------------------- | ------------ |
| 信息包含冲突 | 4 4 1=2 1>3 2>0 0>1 | 信息包含冲突 |
| 信息不完全   | 3 2 1>0 1>2         | 信息不完全   |



## 第三题

本题完整的源代码见[第三题.py](./第三题.py)

### 解题思路

#### 核心算法：动态规划

#### 核心数据结构：数组

乍一思考，用递归这道题可以很快做出来，但庞杂的递归树与极高的时空复杂度显然不够优雅。而我们又发现，这种编码问题实则满足了动态规划的两大条件：

- 是一个求最值问题（最多的编码数）

- 拥有重叠子问题结构

  因此我们开辟一个新的dp数组，问题转化为了求动态规划的核心方程：

  - 连续两位都符合条件可以编码：dp[i] = dp[i-1] + dp[i-2]
  - 不符合条件：
    - 当前数字是0: dp[i] = dp[i-2]
    - 当前数字不是0: dp[i] = dp[i-1]

### 测试用例

#### 功能测试

| 功能描述 | 输入 | 输出 |
| :------: | ---- | ---- |
| 正常输入 | 14   | 2    |
| 正常输入 | 223  | 3    |
| 正常输入 | 130  | 0    |
| 正常输入 | 118  | 3    |

#### 边界值测试

| 边界描述 | 输入 | 输出 |
| -------- | ---- | ---- |
| 0        | 0    | 0    |
| 10       | 10   | 1    |
| 100      | 100  | 0    |
| 1        | 1    | 1    |

#### 特殊输入测试

| 描述           | 输入           | 输出 |
| -------------- | -------------- | ---- |
| null           | null           | 0    |
| -1             | -1             | 0    |
| 1000000000000  | 1000000000000  | 0    |
| -1000000000000 | -1000000000000 | 0    |





